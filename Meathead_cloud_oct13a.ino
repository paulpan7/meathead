/* 
  Sketch generated by the Arduino IoT Cloud Thing "Meathead_cloud"
  https://create.arduino.cc/cloud/things/be12e919-1b2c-4f0c-9c44-b1408a86982e 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float batt_pct;
  float meat_temp1;
  float meat_temp2;
  float meat_temp3;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#include <Adafruit_NeoPixel.h>
#include <ADS1115_WE.h>
#include <Wire.h>
#define NOTE_C4 262
#define NOTE_D4 294
#define NOTE_E4 330
#define NOTE_G4 392
#define NOTE_C5 523
#define NOTE_D5 587
#define NOTE_E5 659
#define I2C_ADDRESS 0x48
#define vbat_sns 36
#define buzzer 25
#define NEOPIXEL_PIN 5
#define home_led_loc 0
#define probe1_led_loc 1
#define probe2_led_loc 2
#define probe3_led_loc 3
#define numAvg 4
#define verbose 0
#define colorVal 200
#define PT1000_type true  // true if using PT1000 3.5mm probe

// // OLD coeff based on oven + DMM
// const long double STEINHART_HART_COEF_A = 6.29394E-04;
// const long double STEINHART_HART_COEF_B = 2.27780E-04;
// const long double STEINHART_HART_COEF_C = 6.58146E-08;

// NEW coeff based on water baths at 0C/25C/100C, bent probe
const long double STEINHART_HART_COEF_A = 7.995170655E-04;
const long double STEINHART_HART_COEF_B = 2.017938878E-04;
const long double STEINHART_HART_COEF_C = 1.480040020E-07;

// Variables for non-blocking rainbow effect
unsigned long previousMillis = 0;  // Store the last time the strip was updated
int wait = 50;                     // Time between updates (milliseconds)
long firstPixelHue = 0;            // Hue of the first pixel
int ctr = 0;
float batt_reading = 0;
float batt_accu = 0;
long t_last;
struct probe_result {
  float res;
  float tempF;
};

Adafruit_NeoPixel pixels(4, NEOPIXEL_PIN, NEO_GRB + NEO_KHZ800);  // 4 pixel
ADS1115_WE adc = ADS1115_WE(I2C_ADDRESS);

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // put your setup code here, to run once:
  Serial.begin(115200);
  Wire.begin();
  configADC();

  // setup Vbatsns ESP32 ADC
  analogSetAttenuation(ADC_11db);  // 6dB - VFS = 2.2V // 11dB - VFS = 3.9V
  adcAttachPin(vbat_sns);
  // Setup NeoPixel
  pixels.begin();  // init NeoPixel
  pixels.clear();
  // animation splash
  rainbow(8);
  pixels.setPixelColor(home_led_loc, pixels.Color(0, colorVal / 2, 0));
  pixels.setPixelColor(probe1_led_loc, pixels.Color(0, 0, 0));
  pixels.setPixelColor(probe2_led_loc, pixels.Color(0, 0, 0));
  pixels.setPixelColor(probe3_led_loc, pixels.Color(0, 0, 0));
  pixels.show();
  //bootMelody();
}

void loop() {

  while (ArduinoCloud.connected() == 0) {
    ArduinoCloud.update();  //required so things don't crash on us
    Serial.println("Waiting for connection to Arduino IoT Cloud");
    // Serial.print("\r");
    breathWait();
  }
  pixels.setPixelColor(home_led_loc, pixels.Color(0, colorVal / 2, 0));
  pixels.show();

  float temp1 = 0;
  float temp2 = 0;
  float temp3 = 0;
  bool probe1Connected = true;
  bool probe2Connected = true;
  bool probe3Connected = true;
  // quick check if probe connected
  // adc.setConvRate(ADS1115_64_SPS);  // fastest sampling
  // if (readProbe(1) < 30) {
  //   probe1Connected = false;
  //   temp1 = -1;
  // }
  // if (readProbe(2) < 30) {
  //   probe2Connected = false;
  //   temp2 = -1;
  // }
  // if (readProbe(3) < 30) {
  //   probe3Connected = false;
  //   temp3 = -1;
  // }

  // // update LEDs
  // updateProbeLED(probe1Connected, probe2Connected, probe3Connected);

  // read probe temp
  adc.setConvRate(ADS1115_32_SPS);  // normal sampling
  if (probe1Connected)
    temp1 = readProbe(1);
  if (probe2Connected)
    temp2 = readProbe(2);
  if (probe3Connected)
    temp3 = readProbe(3);

  if (temp1 < 30) {
    probe1Connected = 0;
    temp1 = -1;
  }
  if (temp2 < 30) {
    probe2Connected = 0;
    temp2 = -1;
  }
  if (temp3 < 30) {
    probe3Connected = 0;
    temp3 = -1;
  }

  updateProbeLED(probe1Connected, probe2Connected, probe3Connected);

  batt_reading = readVbat();

  //readVbat();
  //delay(100);
  meat_temp1 = temp1;
  meat_temp2 = temp2;
  meat_temp3 = temp3;
  batt_accu = batt_accu + batt_reading;

  if (ctr % 20 == 0) {          // update every 30sec
    batt_pct = batt_accu / 20;  // update every 10 cycles
    batt_accu = 0;
  }

  // if (ctr % 40 == 0) { // update every 60sec
  //   WiFi.scanNetworks(0);
  //   rssi = WiFi.RSSI(0);
  // }

  Serial.print(ctr);
  Serial.print(", ");
  Serial.print(temp1, 3);
  Serial.print(", ");
  Serial.print(temp2, 3);
  Serial.print(", ");
  Serial.print(temp3, 3);
  Serial.print(", ");
  Serial.print(batt_pct, 2);
  Serial.print(", ");
  Serial.println(rssi);

  if (ctr % 6 == 0) {  // 10 eqv to 15sec, 6 eqv 10 sec
    Serial.print("updating to cloud, elapsed sec since last update: ");
    Serial.println((millis() - t_last) / 1000, 1);
    ArduinoCloud.update();  //update every ~15sec
    t_last = millis();
  }

  ctr++;
}

//////////////////////////////////////////////// Probe Functions ////////////////////////////////////////////////

float readProbe(int probeCh) {
  struct result;
  // probeCh is the physical port, top to bottom is 1, 2, 3
  double VREF, AIN, Rprobe, tempC;
  float sum_ref = 0;
  float sum_probe = 0;
  // read AIN
  switch (probeCh) {
    case 1:
      for (int i = 0; i < numAvg; i++) {
        sum_probe = sum_probe + readChannel(ADS1115_COMP_2_GND);
        sum_ref = sum_ref + readChannel(ADS1115_COMP_3_GND);
      }
      break;
    case 2:
      for (int i = 0; i < numAvg; i++) {
        sum_probe = sum_probe + readChannel(ADS1115_COMP_1_GND);
        sum_ref = sum_ref + readChannel(ADS1115_COMP_3_GND);
      }
      break;
    case 3:
      for (int i = 0; i < numAvg; i++) {
        sum_probe = sum_probe + readChannel(ADS1115_COMP_0_GND);
        sum_ref = sum_ref + readChannel(ADS1115_COMP_3_GND);
      }
      break;
  }

  AIN = sum_probe / numAvg;
  VREF = sum_ref / numAvg;


  // calculate probe resistance
  Rprobe = -1 * AIN * 100000 / (AIN - 2 * VREF);  // conver to resistance in Ohm
  if (verbose) {
    Serial.print(VREF);
    Serial.print(", ");
    Serial.print(AIN);
    Serial.print(", ");
    Serial.print(Rprobe);
    Serial.print(", ");
  }
  if (!PT1000_type)
    // calculate temp based on Steinhart Hart equation
    tempC = (1 / ((STEINHART_HART_COEF_A) + (STEINHART_HART_COEF_B)*LN(Rprobe) + (STEINHART_HART_COEF_C)*LN(Rprobe) * LN(Rprobe) * LN(Rprobe))) - 273.25;
  else {
    tempC = (Rprobe - 10000);
    tempC = tempC / 3.85055;
  }
  Serial.println(tempC);

  // return in degrees F
  if (tempC < 0)  // probe not connected
  {
    // result.tempF = -1;
    return -1;
  } else {
    // resut.tempF = ((float)((tempC * 9.0) / 5.0 + 32.0));
    //  result.res = Rprobe;
    //return  Rprobe;
    return ((float)((tempC * 9.0) / 5.0 + 32.0));
  }
}

float readChannel(ADS1115_MUX channel) {
  float voltage = 0.0;
  adc.setCompareChannels(channel);
  voltage = adc.getResult_V();  // alternative: getResult_mV for Millivolt
  return voltage;
}

void configADC() {
  // Setup ADS1115
  if (!adc.init()) {
    Serial.println("ADS1115 not connected!");
  }
  /* Set the voltage range of the ADC to adjust the gain
   * Please note that you must not apply more than VDD + 0.3V to the input pins!
   * 
   * ADS1115_RANGE_6144  ->  +/- 6144 mV
   * ADS1115_RANGE_4096  ->  +/- 4096 mV
   * ADS1115_RANGE_2048  ->  +/- 2048 mV (default)
   * ADS1115_RANGE_1024  ->  +/- 1024 mV
   * ADS1115_RANGE_0512  ->  +/- 512 mV
   * ADS1115_RANGE_0256  ->  +/- 256 mV
   */
  adc.setVoltageRange_mV(ADS1115_RANGE_4096);
  /* Set the inputs to be compared
   *  
   *  ADS1115_COMP_0_1    ->  compares 0 with 1 (default)
   *  ADS1115_COMP_0_3    ->  compares 0 with 3
   *  ADS1115_COMP_1_3    ->  compares 1 with 3
   *  ADS1115_COMP_2_3    ->  compares 2 with 3
   *  ADS1115_COMP_0_GND  ->  compares 0 with GND
   *  ADS1115_COMP_1_GND  ->  compares 1 with GND
   *  ADS1115_COMP_2_GND  ->  compares 2 with GND
   *  ADS1115_COMP_3_GND  ->  compares 3 with GND
   */
  // adc.setCompareChannels(ADS1115_COMP_0_3);  //comment line/change parameter to change channel
  /* Set the conversion rate in SPS (samples per second)
   * Options should be self-explaining: 
   * 
   *  ADS1115_8_SPS 
   *  ADS1115_16_SPS  
   *  ADS1115_32_SPS 
   *  ADS1115_64_SPS  
   *  ADS1115_128_SPS (default)
   *  ADS1115_250_SPS 
   *  ADS1115_475_SPS 
   *  ADS1115_860_SPS 
   */
  adc.setConvRate(ADS1115_250_SPS);        //uncomment if you want to change the default
  adc.setMeasureMode(ADS1115_CONTINUOUS);  //comment line/change parameter to change mode
}


//////////////////////////////////////////////// UTLITY ////////////////////////////////////////////////
float readVbat() {
  float accu = 0;
  float vbat = 0;
  adcAttachPin(vbat_sns);
  for (int i = 0; i < 32; i++) {
    vbat = analogRead(vbat_sns);
    accu = accu + vbat;
  }
  vbat = accu / 32;
  double battpct = 0;
  float vbatf = (2 * 3.28 * 1.106 * vbat) / 4095;
  battpct = 123 - 123 / pow(1 + pow(vbatf / 3.7, 80), 0.165);  // li-ion SOC emperical fit
  if (0) {
    Serial.print("\nVBAT: ");
    Serial.print(vbat);
    Serial.print(", ");
    Serial.print(vbatf, 3);
    Serial.print(", ");
    Serial.println(battpct, 2);
  }
  // pct=123-123/(1+(E7/3.7)^80)^0.165
  return battpct;
}
double LN(float num) {
  return double(log(num) / log(2.718));
}

void updateProbeLED(int probe1, int probe2, int probe3) {
  if (probe1 > 0)
    pixels.setPixelColor(probe1_led_loc, pixels.Color(0, 0, colorVal));  // BLUE
  else
    pixels.setPixelColor(probe1_led_loc, pixels.Color(0, 0, 0));  // turn off LED

  if (probe2 > 0)
    pixels.setPixelColor(probe2_led_loc, pixels.Color(colorVal / 2, colorVal / 2, 0));  // YELLOW
  else
    pixels.setPixelColor(probe2_led_loc, pixels.Color(0, 0, 0));  // turn off LED

  if (probe3 > 0)
    pixels.setPixelColor(probe3_led_loc, pixels.Color(colorVal, 0, colorVal / 4));  // PURPLE
  else
    pixels.setPixelColor(probe3_led_loc, pixels.Color(0, 0, 0));  // turn off LED

  pixels.show();
}
void breathWait() {
  for (int i = 1; i < colorVal; i++) {
    pixels.setPixelColor(home_led_loc, pixels.Color(0, i, 0));
    pixels.show();
    delay(8);
  }
  for (int i = colorVal; i > 1; i--) {
    pixels.setPixelColor(home_led_loc, pixels.Color(0, i, 0));
    pixels.show();
    delay(8);
  }
}

void blinkMain(int numTimes) {
  for (int i = 0; i < numTimes; i++) {
    pixels.setPixelColor(home_led_loc, pixels.Color(0, 0, 0));
    pixels.show();
    delay(100);
    pixels.setPixelColor(home_led_loc, pixels.Color(0, colorVal, 0));
    pixels.show();
    delay(100);
  }
}

void rainbow(int wait) {
  // unsigned long currentMillis = millis();  // Get the current time
  // // Only update the pixels if the wait time has passed
  for (long firstPixelHue = 0; firstPixelHue < 2 * 65536; firstPixelHue += 256) {
    // currentMillis = millis();
    // if (currentMillis - previousMillis >= wait) {
    //   previousMillis = currentMillis;  // Save the time of the last update
    for (int i = 0; i < pixels.numPixels(); i++) {
      int pixelHue = firstPixelHue + (i * 65536L / pixels.numPixels());
      pixels.setPixelColor(i, pixels.gamma32(pixels.ColorHSV(pixelHue)));
    }
    pixels.show();
    delay(wait);
  }
}
// void rainbow(int wait) {
//   for (long firstPixelHue = 0; firstPixelHue < 2 * 65536; firstPixelHue += 256) {
//     for (int i = 0; i < pixels.numPixels(); i++) {
//       int pixelHue = firstPixelHue + (i * 65536L / pixels.numPixels());
//       pixels.setPixelColor(i, pixels.gamma32(pixels.ColorHSV(pixelHue)));
//     }
//     pixels.show();
//     delay(wait);
//   }
// }
void rainbowNonBlocking(int wait) {
  unsigned long currentMillis = millis();  // Get the current time
  // Only update the pixels if the wait time has passed
  if (currentMillis - previousMillis >= wait) {
    previousMillis = currentMillis;  // Save the time of the last update

    // Loop through each pixel and update its color
    for (int i = 0; i < pixels.numPixels(); i++) {
      // Calculate the hue for the current pixel
      int pixelHue = firstPixelHue + (i * 65536L / pixels.numPixels());

      // Set the pixel color using the calculated hue
      pixels.setPixelColor(i, pixels.gamma32(pixels.ColorHSV(pixelHue)));
    }

    // Show the updated colors on the strip
    pixels.show();

    // Increment the hue of the first pixel, and wrap around when it reaches the max value
    firstPixelHue += 256;
    if (firstPixelHue >= 65536 * 2) {
      firstPixelHue = 0;
    }
  }
}

void bootMelody() {
  int bootMelody[] = {
    NOTE_C4, NOTE_E4, NOTE_G4, NOTE_C5,  // Ascending C major chord
    NOTE_D5, NOTE_G4, NOTE_E4,           // Small progression
    NOTE_C5, NOTE_D5, NOTE_E5, NOTE_D5,  // Slightly longer descending part
    NOTE_C5, NOTE_G4, NOTE_C5            // Return to tonic for closure
  };

  // Duration for each note (in milliseconds)
  int noteDurations[] = {
    300, 300, 300, 500,  // Ascending chord
    300, 300, 300,       // Progression
    300, 300, 300, 300,  // Descending
    500, 300, 600        // Final tonic
  };
  for (int i = 0; i < sizeof(bootMelody) / sizeof(int); i++) {
    int noteDuration = noteDurations[i];
    tone(buzzer, bootMelody[i], noteDuration / 2);

    // Pause between notes
    int pauseBetweenNotes = noteDuration / 2 * 1.3;
    delay(pauseBetweenNotes);

    // Stop the tone to create a gap between notes
    noTone(buzzer);
  }
}
